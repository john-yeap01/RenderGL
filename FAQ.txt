Two sizes exist
1) Window size (logical points)
What you pass to:

glfwCreateWindow(800, 800, ...)
glfwGetWindowSize(...)
glfwGetCursorPos(...)

This is in screen points (“UI units”). On Retina, 1 point is often 2×2 pixels.

2) Framebuffer size (actual pixels)
What OpenGL renders into:

glfwGetFramebufferSize(...)
glViewport(...)

This is the real pixel resolution of the back buffer.
On your Mac you printed:

framebuffer = 1600×1222

If your window size is ~800×611, that’s exactly 2× scale (Retina).
Why OpenGL needs framebuffer size
glViewport(0,0,w,h) defines how NDC (-1..+1) maps to pixels in the framebuffer.
If you give OpenGL the wrong size (800×800) but the actual framebuffer is 1600×1222, you’re telling it:
“treat this buffer like it’s square”
when it’s actually rectangular in pixels.
Result: stretching/squashing.
That’s why your pyramid “looks different”.
Why the camera needs the same aspect ratio as the viewport

Your projection matrix uses:

aspect = width / height

This aspect must match the viewport aspect, or you get distortion.
So these two must agree:

glViewport(0,0, fbW, fbH) ✅ uses framebuffer
glm::perspective(..., fbW/fbH, ...) ✅ should use framebuffer too

If you instead use 800/800 for the projection, your math assumes square, but your viewport is 1600/1222 (~1.31). Distortion.
Why mouse input is different (and why window size matters there)
glfwGetCursorPos() returns cursor position in window coordinates (points), not framebuffer pixels.

So for mouse-look, you should compare mouseX/mouseY against the window center, not framebuffer center.

That’s why the “right” combo on macOS Retina is:
Projection + viewport: framebuffer size
Mouse coordinates: window size
This is not “extra stuff”; it’s just you finally handling the two coordinate systems correctly.

Why the tutorial “doesn’t need it”
Common reasons:
They’re on Windows / non-Retina display: scale factor is 1.0, so window==framebuffer.
They never resize and they chose 800×800, so even if there’s a mismatch, it’s less noticeable.
They are wrong, but their output still “looks okay” for a beginner scene.
The mental model to keep
Window size = UI coordinate space (mouse, window dimensions)
Framebuffer size = render target pixel space (viewport, projection aspect)
If you remember just that, all the “why Mac needs extra stuff” disappears.





Previous vertices
// Vertices coordinates
// triangle 1
// GLfloat vertices[] = {
//     // Positions                                 // Colors (R, G, B)
//     -0.5f, -0.5f * float(sqrt(3)) / 3, 0.0f,      1.0f, 0.0f, 0.0f,  // Red     - Lower left corner
//      0.5f, -0.5f * float(sqrt(3)) / 3, 0.0f,      0.0f, 1.0f, 0.0f,  // Green   - Lower right corner
//      0.0f,  0.5f * float(sqrt(3)) * 2 / 3, 0.0f,  0.0f, 0.0f, 1.0f,  // Blue    - Upper corner
//     -0.5f / 2, 0.5f * float(sqrt(3)) / 6, 0.0f,   1.0f, 1.0f, 0.0f,  // Yellow  - Inner left
//      0.5f / 2, 0.5f * float(sqrt(3)) / 6, 0.0f,   0.0f, 1.0f, 1.0f,  // Cyan    - Inner right
//      0.0f, -0.5f * float(sqrt(3)) / 3, 0.0f,      1.0f, 0.0f, 1.0f   // Magenta - Inner down
// };

// square  1
// GLfloat vertices[] = {
//     // positions          // colors           // texture coords
//      0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f,   // top right
//      0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f,   // bottom right
//     -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f,   // bottom left
//     -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f    // top left 
// };

// Indices for vertices order
//triangle 1
// GLuint indices[] =
// {
// 	0, 3, 5, // Lower left triangle
// 	3, 2, 4, // Lower right triangle
// 	5, 4, 1 // Upper triangle
// };

//square 1
// GLuint indices[] = {
//     0, 1, 2,   // first triangle (lower-left, lower-right, upper-right)
//     2, 3, 0    // second triangle (upper-right, upper-left, lower-left)
// };


